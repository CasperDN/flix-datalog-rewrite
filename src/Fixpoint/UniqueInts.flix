/*
 * Copyright 2025 Casper Dalgaard Nielsen
 *                Adam Yasser Tallouzi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///
/// The purpose of `UniqueInts` is to assign unique numbers/identifiers to elements.
///
/// Example of use: When generating joins automatically we have data of type 
/// `(RelSym, Search)`. These needs to be placed somewhere in memory. For 
/// a pair `(rel, search)` calling `getIndex((rel, search))` will return its
/// index if it has been seen before and otherwise return the new index
/// which henceforth will be returned for subsequent queries of `(rel, search)`.
///
/// `ReverseUniqueInts` allows using an index, `i`, assigned by `UniqueInts`, and get
/// the value, which `UniqueInts` assigned index `i`.
///

mod Fixpoint {
    @Internal
    struct UniqueInts[k: Type, r: Region] {
        rc: Region[r],
        map: MutMap[k, Int32, r],
        counter: Counter[r]
    }

    @Internal
    struct ReverseUniqueInts[k: Type, r: Region] {
        map: Map[Int32, k]
    }

    mod UniqueInts {
        use Fixpoint.Counter
        use Fixpoint.ReverseUniqueInts
        use Fixpoint.UniqueInts

        ///
        /// Returns an empty mapping from `k` to identifiers.
        ///
        @Internal
        pub def empty(rc: Region[r]): UniqueInts[k, r] \ r =
            new UniqueInts @ rc {
                rc = rc,
                map = MutMap.empty(rc),
                counter = Counter.fresh(rc)
            }

        ///
        /// Returns the index of `val` generated by `state`.
        ///
        @Internal
        pub def getIndex(val: k, state: UniqueInts[k, r]): Int32 \ r with Order[k] = 
            let map = state->map;
            let counter = state->counter;
            match MutMap.get(val, map) {
                case None =>
                    let id = Counter.getAndIncrement(counter);
                    MutMap.put(val, id, map);
                    id
                case Some(v) => v
            }

        ///
        /// Returns the current mapping of `state` as a map.
        ///
        @Internal
        pub def toMap(state: UniqueInts[k, r]): Map[k, Int32] \ r = {
            state->map |> MutMap.toMap
        }

        ///
        /// Returns the maximal assigned identifier of `state`.
        ///
        @Internal
        pub def get(state: UniqueInts[k, r]): Int32 \ r = {
            Counter.get(state->counter)
        }

        ///
        /// Returns an `ReverseUniqueInts` of `state` allowing mapping identifiers
        /// back to the values they represent.
        ///
        @Internal
        pub def reverse(state: UniqueInts[k, r]): ReverseUniqueInts[k, r] \ r with Order[k] =
            let map = state->map;
            let rc = state->rc;
            let reverseMap = MutMap.foldLeftWithKey(acc -> key -> val -> Map.insert(val, key, acc), Map#{}, map);
            new ReverseUniqueInts @ rc {map = reverseMap}
    }

    mod ReverseUniqueInts {
        use Fixpoint.ReverseUniqueInts
        use Fixpoint.Util.getOrCrash

        ///
        /// Returns an `ReverseUniqueInts` the value was assigned
        /// the identifier `val`
        ///
        pub def fromIndex(val: Int32, reverseState: ReverseUniqueInts[k, r]): k = 
            let map = reverseState->map;
            getOrCrash(Map.get(val, map))
    }

}
