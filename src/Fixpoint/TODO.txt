Ram.flix:
    Add 'exit' at some point, when stuff starts to work.
    Possibly add support for more searches.
    Maybe add not equal? Could allow more optimal searching of structures
    Implement equality for PredSym using only int id
    Implement order for PredSym using only int id
    For Query: Add extra field describing which index to use. Could use a simple int32.

Stratifier.flix:
    Rewrite using Tarjan's SCC algorithm and check if a StrongEdge appears in SCC

General note:
    The interpreter should receive some meta-data about which indexes should be created for the different relations
    The different facts1, facts2, ... and so on is used by Lowering.scala (Fixpoint.Solver.facts$arity)
    A reason for using RAM: Index selection can then also be applied with respect to the Delta-relations, if we want to

WEIRD BEHAVIOR:
    Apparently all PredSym's are generated with an ID of 0?


Spørg Magnus om forskel på følgende:

        let test = 
        Vector.foldRight(a -> b -> {
            match a {
                case Constraint(HeadAtom(predSym, _, headTerms), _) => 
                    let x = Vector.map(compileHeadTerm(Map.empty()), headTerms); 
                    match Predicates.getPredSymFullId(Predicates, predSym) {
                        case PredSym(_, id) => Map.insertWith(List.append, id, x :: Nil, b)
                    }
                    // ()
            }
            // let _ = Predicates.getPredSymFullId(Predicates, PredSym("", 1i64)); 
            // b
        }, Map#{}, facts);
        Map.map(List.toVector, test);


        // Map.empty()
        // let test = 
        // Vector.foldRight(match Constraint(HeadAtom(predSym, _, headTerms), _) ->
        //             let x = Vector.map(compileHeadTerm(Map.empty()), headTerms);
        //             match Predicates.getPredSymFullId(Predicates, predSym) {
        //                 case PredSym(_, id) => Map.insertWith(List.append, id, x :: Nil)
        //             }, Map#{}, facts);
        // Map.map(List.toVector, test)